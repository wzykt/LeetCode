### 144
前序遍历（迭代法）

![img.png](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif)


### 145
中序遍历（迭代法）

![](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif)

### 145
后序遍历（迭代法）

![](https://img-blog.csdnimg.cn/20200808200338924.png)


### 如何构建二叉树
题目：105和106

前序和中序，中序和后续都可以确定一颗二叉树

前序和后序不能唯一确定一颗二叉树！，因为没有中序遍历无法确定左右部分，也就是无法分割。

解题步骤

第一步：如果数组大小为零的话，说明是空节点了。

第二步：如果不为空，那么取后序数组最后一个元素作为节点元素或者前序数组第一个元素作为节点。

第三步：找到后序数组最后一个元素或者前序数组第一个元素在中序数组的位置，作为切割点

第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）

第五步：切割后序数组或前序数组，切成后序左数组和后序右数组，或者前序左数组和前序右数组

第六步：递归处理左区间和右区间


构建树的递归伪代码
```java
public TreeNode build(参数){
    
    if(){
        return null;
    }
    
    if(){
        return new TreeNode(val1);
    }
    
    TreeNode node = new TreeNode(val2);
    
    node.left = build(参数);
    node.right = build(参数);
    
}
```


### BST二叉搜索树

中序遍历结果就行排好序的，要利用二叉搜索树的特性

伪代码
```java
需要用到的变量

public void searchBST(TreeNode cur) {
    if (cur == NULL) return;
    searchBST(cur.left);       // 左
    （处理节点）                // 中
    searchBST(cur.right);      // 右
    return;
}
```

相关题目：98、530、501

### 二叉树的回溯
二叉树的递归函数

递归函数的返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

* 如果需要搜索整颗二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
* 如果需要搜索整颗二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
* 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

**后序遍历**

后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。

搜索一条边的写法：
```java
if (递归函数(root.left)) return;
if (递归函数(root.right)) return;
```

搜索整个树写法：
```java
left = 递归函数(root.left);
right = 递归函数(root.right);
left与right的逻辑处理;
```

在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。


其他遍历，根据需求确定处理逻辑的位置