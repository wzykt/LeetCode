回溯函数终止条件伪代码如下：

```java
if (终止条件) {
    存放结果;
    return;
}
```

回溯函数遍历过程伪代码如下：

```java
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```
for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

backtracking这里自己调用自己，实现递归。

大家可以从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

### 关于回溯的去重

要理解“树层去重”和“树枝去重”

基本使用伪代码
```java
used = new boolean[nums.length];

for (){
    if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){
        continue;
    }
    add
    used[i] = true;
    递归调用;
    removeLast
    used[i] = false;
}
```

---

#### 47.全排列2
大家发现，去重最为关键的代码为：

```java
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

如果改成 used[i - 1] == true， 也是正确的!，去重代码如下：

```java
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用used[i - 1] == false，如果要对树枝前一位去重用used[i - 1] == true。

对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！

这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![](https://img-blog.csdnimg.cn/20201124201406192.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![](https://img-blog.csdnimg.cn/20201124201431571.png)
大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。



### 集合和组合

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！

其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。

那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！

有同学问了，什么时候for可以从0开始呢？

求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合


